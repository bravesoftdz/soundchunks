; Z80 driver for replaying RSE SoundChunks PCM streams
; By GliGli

; ###########################	   define      ##############################

	INCLUDE "z80_def.i80"	; basic definitions

; ###########################	    var	       ##############################

RSCPARAMS	EQU	0x18

RSCFLAGS	EQU	RSCPARAMS+0x00	// 0: 68k ready; 1: Z80 ready; 2: track finished; 3: stop requested
RSCBANK		EQU	RSCPARAMS+0x01

SAMPLES_PER_CHUNK_SHIFT		EQU	2
SAMPLES_PER_CHUNK		EQU	(1 << SAMPLES_PER_CHUNK_SHIFT)
CHUNKS_PER_FRAME		EQU	256

CHUNKBUFFER0	EQU	0x0800
CHUNKBUFFER1	EQU	0x0C00
INDEXBUFFER	EQU	0x1000

CHUNKBUFFER_SZ	EQU	(CHUNKS_PER_FRAME * SAMPLES_PER_CHUNK)
INDEXBUFFER_SZ	EQU	455 * 9

; ###########################	   macro       ##############################

	INCLUDE "z80_mac.i80"  ; basic macros

	; data -> YM2612 low reg address
	macro	ymW0 addr, data
	
	LD	HL, YMPORT0

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; data -> YM2612 high reg address
	macro	ymW1 addr, data
	
	LD	HL, YMPORT2

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; 8bit sample in smp
	macro	ymWSH smp
	
	LD	(HL), D
	INC	L
	LD	(HL), smp
	DEC	L

	endm

	; 9th sample bit in Carry
	macro	ymWSL
	
	LD	(HL), E
	INC	L

	SBC	A, A
	AND	L		; L = 0x9 here, so it's fine to write the 9th DAC bit

	LD	(HL), A
	DEC	L

	endm

	macro	ymWSL1
	
	LD	(HL), E
	INC	L
	
	LD	(HL), L		; L = 0x9 here, so it's fine to write the 9th DAC bit
	DEC	L

	endm

	; wait YM2612 timer A and reset it
	macro	ymWT
	
.wait:	BIT	0, (HL)
	JP	Z, .wait
	
	LD	(HL), 0x27
	INC	L

	LD	(HL), 0x15
	DEC	L
	
	endm
	
	; play a chunk sample in 8bit mode
	macro	playHiSample smp
	
	ymWSL1
	ymWSH smp

	ymWT

	endm
	
	; play a chunk sample in 9bit mode
	macro	playLoSample smp

	SRL	smp
	ymWSL
	LD	A, smp
	ADD	H		; H = 64 here
	ymWSH A

	ymWT

	endm

; ###########################	    init       ##############################

	ORG	0x0000

init:
	DI			; disable ints
	IM	0x01		; set int mode 1
	JP	start		; jump to start


; ###########################	  interrupt    ##############################

	BLOCK	0x0038-$

interrupt:			     ; do nothing in this program
	RETI


; ###########################	    main       ##############################

start:
	; wait for 68k side init
	LD	A, (RSCFLAGS)
	RRCA
	JP	NC, start

	; set config
	LD	A, (RSCBANK)
	setBankFast

	; Enable DAC
	ymW0	0x2b, 0x80
	
	; DAC Pan = LR
	ymW1	0xb6, 0xc0

	; Timer A enabled @ 26390Hz
	ymW0	0x24, 0xff
	ymW0	0x25, 0x02
	ymW0	0x27, 0x15

	; DAC init sample
	ymW0	0x2a, 0x80
	ymW0	0x2c, 0x08

	; init player
	EXX
	LD	DE, 0x2a2c
	LD	HL, YMPORT0 + 8		; we need L = 8 for the algo and it points on a mirror
	EXX

	; preload buffers
	
	LD	HL, 0x8000
	
	LD	A, (HL)
	LD	IYL, A
	INC	L
	LD	A, (HL)
	LD	IYH, A
	INC	L

	LD	DE, CHUNKBUFFER0
	LD	BC, CHUNKBUFFER_SZ
	LDIR

	LD	A, H
	LD	IXH, A
	LD	A, L
	LD	IXL, A
restart:	
	LD	A, IXH
	LD	H, A
	LD	A, IXL
	LD	L, A

	LD	DE, INDEXBUFFER
	LD	BC, INDEXBUFFER_SZ
	ADD	IX, BC
	LDIR

	LD	DE, INDEXBUFFER
	LD	HL, CHUNKBUFFER0
	LD	IY, INDEXBUFFER_SZ / 9

	; Z80 side init done
	LD	A, (RSCFLAGS)
	OR	2
	LD	(RSCFLAGS), A

	; handle 68k track stop request

	LD	A, (RSCFLAGS)
	AND	8
	JP	Z, main_loop

	LD	A, (RSCFLAGS)
	OR	4
	LD	(RSCFLAGS), A

stop:	JR	stop

chunkIdx_loSmp:
	POP	BC
	playLoSample C
	playLoSample B
	POP	BC
	playLoSample C
	playLoSample B
	EXX
	
	DJNZ	chunkIdx_loop

	; main loop, one 8 chunks block at a time

main_loop:
	
	; check for end of frame

	DEC	IY
	LD	A, IYL
	OR	IYH
	JP	Z, restart

	; load bit shift for 8 chunk idxs
	LD	A, (DE)
	LD	C, A
	INC	DE

	LD	B, 8
	JP	chunkIdx_loop

chunkIdx_loop:

	; load chunk index

	LD	A, (DE)
	INC	DE

	; compute chunk address

	LD	L, A
	LD	A, H
	RRA
	RRA
	SLA	L
	RLA
	SLA	L
	RLA
	LD	H, A

	LD	SP, HL

	; play the chunk samples

	SLA	C
	EXX
	JP	NC, chunkIdx_loSmp
	
	POP	BC
	playHiSample C
	playHiSample B
	POP	BC
	playHiSample C
	playHiSample B
	EXX

	DJNZ	chunkIdx_loop
	JP	main_loop

	END
