; Z80 driver for replaying RSE SoundChunks PCM streams
; By GliGli

; ###########################	   define      ##############################

	INCLUDE "z80_def.i80"	; basic definitions

; ###########################	    var	       ##############################

RSCPARAMS	EQU	0x110

RSCFLAGS	EQU	RSCPARAMS+0x00	// 0: 68k ready; 1: Z80 ready; 2: track finished; 3: stop requested
RSCBANK		EQU	RSCPARAMS+0x01
RSC68KLOCKED	EQU	RSCPARAMS+0x02  // 7: "68k bus locked" flag, managed by the 68k
RSCBLOCKSLEFT	EQU	RSCPARAMS+0x03
RSCNEXTCHUNKBUF	EQU	RSCPARAMS+0x04

SAMPLES_PER_CHUNK_SHIFT		EQU	2
SAMPLES_PER_CHUNK		EQU	(1 << SAMPLES_PER_CHUNK_SHIFT)
CHUNKS_PER_FRAME		EQU	256
NOBUFLEFT_FIRST_PART_BLKCNT	EQU	96

CHUNKBUFFER0	EQU	0x0400
INDEXBUFFER0	EQU	0x0800
CHUNKBUFFER1	EQU	0x1400
INDEXBUFFER1	EQU	0x1800

CHUNKBUFFER_SZ	EQU	(CHUNKS_PER_FRAME * SAMPLES_PER_CHUNK)
INDEXBUFFER_SZ	EQU	256 * 9

; ###########################	   macro       ##############################

	INCLUDE "z80_mac.i80"  ; basic macros

	; data -> YM2612 low reg address
	macro	ymW0 addr, data
	
	LD	HL, YMPORT0

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JR	NZ, .wait

	endm
	
	; data -> YM2612 high reg address
	macro	ymW1 addr, data
	
	LD	HL, YMPORT2

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JR	NZ, .wait

	endm
	
	; 8bit sample in A
	macro	ymWS
	
	LD	(YMPORT1), A

	endm

	; wait YM2612 timer A and reset it
	macro	ymWT

.wait:	
	BIT	0, (IX + 0)
	JR	Z, .wait
	
	LD	(IX + 0), 0x27
	LD	(IX + 1), 0x15
	LD	(IX + 0), 0x2a

	endm

	; copy stream data to the next buffer when the 68k bus is available
	macro	preloadBuffer
	
	EXX		; *

	LD	A, (RSC68KLOCKED)
	OR	B
	CPL
	AND	H
	JP	M, .do_buffer

	; handle potential bank change
	BIT	7, H
	CALL	Z, bankChange
	OR	A			; roughly match do_buffer timing (also reset carry)
	JR	.done

.do_buffer

	LDI
	LDI

.done:
	EXX		; *
		
	endm
	
	; run per sample background tasks
	macro	sampleYield idx

	if idx == 0
		ymWT
	else
		preloadBuffer
	endif

	endm

	; play a chunk sample in 8bit mode
	macro	playHiSample idx
	
	sampleYield idx

	LD	A, (DE)

	INC	D
	NOP				; match playLoSample timing
	NOP
	
	ymWS

	endm
	
	; play a chunk sample in 9bit mode
	macro	playLoSample idx
	
	if idx > 0
		INC	D
	endif

	sampleYield idx

	LD	A, (DE)

	RRA				; Carry should always be 0 at this point
	ADD	IXH			; IXH = 64 here

	ymWS

	endm

	; play the chunk samples
	macro	playChunkSamples chkIdx

	RL	C
	JR	C, .hiSmp
	
	playLoSample 0
	playLoSample 1
	playLoSample 2
	playLoSample 3

	if chkIdx = 0
		JP chunkIdx_loop
	else
		DJNZ	chunkIdx_start
		JP	main_loop
	endif

.hiSmp:
	playHiSample 0
	playHiSample 1
	playHiSample 2
	playHiSample 3

.end
	endm

; ###########################	    init       ##############################

	ORG	0x0000

init:
	DI			; disable ints
	JP	start		; jump to start


; ###########################	    main       ##############################

	BLOCK	RSCPARAMS + 0x10 - $

start:
	; wait for 68k side init
	LD	A, (RSCFLAGS)
	RRCA
	JP	NC, start

	; set config
	LD	A, (RSCBANK)
	setBankFast

	; Enable DAC
	ymW0	0x2b, 0x80
	
	; DAC Pan = LR
	ymW1	0xb6, 0xc0

	; Timer A enabled @ 26390Hz / 4
	ymW0	0x24, 0xfe
	ymW0	0x25, 0x00
	ymW0	0x27, 0x15

	; DAC init sample

	ymW0	0x2c, 0x08
	ymW0	0x2a, 0x80

	; account for what we will preload

	LD	HL, 0x8000
	LD	A, (HL)
	LD	(RSCBLOCKSLEFT), A

	; preload buffers

	INC	L
	LD	DE, CHUNKBUFFER0
	LD	BC, CHUNKBUFFER_SZ + INDEXBUFFER_SZ
	LDIR

	INC	HL			; compensate (*)
	INC	HL

	; init player

	DEC	BC
	EXX

	LD	IX, YMPORT0
	LD	IYH, high INDEXBUFFER1
	LD	A, high CHUNKBUFFER0
	LD	(RSCNEXTCHUNKBUF), A

	EX	AF
	SCF
	EX	AF
	
	; Z80 side init done
	LD	A, (RSCFLAGS)
	OR	2
	LD	(RSCFLAGS), A

	JR	restart

noBufLeft:
	EX	AF
	JP	NC, nblSecondBlockPart	; F' Carry holds block part information

	LD	A, C			; load next frame block count into A'
	
	OR	A			; zero blocks = termination (also clears F' Carry)
	JP	Z, playerStop
	EX	AF

	; first part we load the chunks

	INC	(HL)			;  Inc(RSCBLOCKSLEFT) (ensure we return to noBufLeft for the second part)

	LD	A, IYH
	XOR	0x10			; double optimised buffer switch here
	LD	H, A
	LD	L, 0
	LD	SP, HL
	LD	IYH, A

	LD	BC, RSCNEXTCHUNKBUF

	LD	A, (BC)
	XOR	0x10
	LD	H, A
	LD	(BC), A

	LD	BC, CHUNKBUFFER_SZ - 1

	DEC	DE			; compensate (*)

	LD	IYL, NOBUFLEFT_FIRST_PART_BLKCNT	; about 1 / 3 of a block

	JP	bufEnd

nblSecondBlockPart:
	LD	(HL), A			; HL = RSCBLOCKSLEFT
	SCF
	EX	AF

	; second part we load the first block

	LD	A, IYH
	XOR	0x10
	LD	H, A
	LD	L, 0

	LD	BC, INDEXBUFFER_SZ - 1 + 2		; more bytes than needed to load possible next frame blkCnt (*)

	LD	IYL, 256 - NOBUFLEFT_FIRST_PART_BLKCNT	; rest of the block

	JP	bufEnd

restart:	
	; frame streaming / frame change

	EXX
	
	INC	BC
	ADD	HL, BC			; skip what wasn't buffered by preloadBuffer

	EX	DE, HL

	DEC	L
	DEC	L
	LD	C, (HL)			;  load possible blkCnt in C (*)

	LD	HL, RSCBLOCKSLEFT
	
	DEC	(HL)
	JP	Z, noBufLeft

	; prepare next block

	LD	BC, INDEXBUFFER_SZ - 1 + 2		; more bytes than needed to load possible next frame blkCnt (*)

	DEC	DE			; compensate (*)
	DEC	DE

	; double buffer handling / switch

	LD	A, IYH
	LD	H, A
	LD	L, 0

	XOR	0x10

	EXX
	LD	H, A
	LD	L, 0
	LD	SP, HL
	LD	HL, (RSCNEXTCHUNKBUF - 1)	; next chunk buffer address in H
	EXX

	LD	IYH, A
	LD	IYL, 0				; 256 blocks

bufEnd:

	EX	DE, HL
	EXX

	; handle 68k track stop request

	LD	A, (RSCFLAGS)
	AND	8
	JP	Z, main_loop_noEof

playerStop:
	LD	A, (RSCFLAGS)
	OR	4
	LD	(RSCFLAGS), A

	ymW0	0x2a, 0x80
	ymW0	0x2c, 0x08

	HALT

bankChange:
	LD	A, (RSCBANK)
	INC	A
	LD	(RSCBANK), A

	LD  H, high BANKREG     ; HL = BANKREG              ' 10
	LD  (HL), A             ; #1 (bit 15)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #2 (bit 16)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #3 (bit 17)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #4 (bit 18)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #5 (bit 19)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #6 (bit 20)               ' 7
	RRA                     ;                           ' 4
	LD  (HL), A             ; #7 (bit 21)               ' 7
	LD  (HL), H             ; #8 (bit 22 = 0)           ' 7
	LD  (HL), H             ; #9 (bit 23 = 0)           ' 7

	LD	H, 0x80

	BIT	0, L
	RET	Z
	
	; "repair" wrong byte if we went past bank end
	DEC	DE
	DEC	L
	INC	BC
	LDI

	RET

; ###########################	  main loop    ##############################

	BLOCK	INDEXBUFFER0 + INDEXBUFFER_SZ + 0x10 - $

restart_trampoline:
	JP restart

main_loop:
	
	; check for end of frame

	DEC	IYL
	JR	Z, restart_trampoline

main_loop_noEof:

	; load bit shift for 8 chunk idxs
	POP	BC
	DEC	SP

	LD	B, 4
	JP	chunkIdx_start

chunkIdx_loop:

	; chunk address in DE
	LD	D, H
	LD	E, L

	playChunkSamples 1

	DEC	B
	JP	Z, main_loop

chunkIdx_start:

	; load 2 chunk indexes
	POP	DE
	LD	L, D

	; chunk address in DE
	LD	D, H

	playChunkSamples 0

	JP	chunkIdx_loop

	END
