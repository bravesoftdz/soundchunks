; Z80 driver for replaying RSE SoundChunks PCM streams
; By GliGli

; ###########################	   define      ##############################

	INCLUDE "z80_def.i80"	; basic definitions

; ###########################	    var	       ##############################

RSCPARAMS	EQU	0x100

RSCFLAGS	EQU	RSCPARAMS+0x00	// 0: 68k ready; 1: Z80 ready; 2: track finished; 3: stop requested
RSCBANK		EQU	RSCPARAMS+0x01
RSC68KLOCKED	EQU	RSCPARAMS+0x02  // 7: "68k bus locked" flag, managed by the 68k
RSCCURIDXBUF	EQU	RSCPARAMS+0x03
RSCFRAMELEFT	EQU	RSCPARAMS+0x04
RSCTMP16BIT	EQU	RSCPARAMS+0x06

SAMPLES_PER_CHUNK_SHIFT		EQU	2
SAMPLES_PER_CHUNK		EQU	(1 << SAMPLES_PER_CHUNK_SHIFT)
CHUNKS_PER_FRAME		EQU	256

CHUNKBUFFER0	EQU	0x0400
INDEXBUFFER0	EQU	0x0800
CHUNKBUFFER1	EQU	0x1400
INDEXBUFFER1	EQU	0x1800

CHUNKBUFFER_SZ	EQU	(CHUNKS_PER_FRAME * SAMPLES_PER_CHUNK)
INDEXBUFFER_SZ	EQU	256 * 9

; ###########################	   macro       ##############################

	INCLUDE "z80_mac.i80"  ; basic macros

	; data -> YM2612 low reg address
	macro	ymW0 addr, data
	
	LD	HL, YMPORT0

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; data -> YM2612 high reg address
	macro	ymW1 addr, data
	
	LD	HL, YMPORT2

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; 8bit sample in smp
	macro	ymWSH smp
	
	LD	(HL), 0x2a
	INC	L
	LD	(HL), smp
	DEC	L

	endm

	; 9th sample bit in Carry
	macro	ymWSL
	
	LD	(HL), 0x2c
	INC	L

	SBC	A, A
	AND	L		; L = 9 here, so it's fine to write the 9th DAC bit (which is bit 3; bit 0 is ignored)

	LD	(HL), A
	DEC	L

	endm

	macro	ymWSL1
	
	LD	(HL), 0x2c
	INC	L
	
	LD	(HL), L		; L = 9 here, so it's fine to write the 9th DAC bit (which is bit 3; bit 0 is ignored)
	DEC	L

	endm

	; wait YM2612 timer A and reset it
	macro	ymWT

.wait:	BIT	0, (HL)
	JR	Z, .wait

	LD	(HL), 0x27
	INC	L

	LD	(HL), 0x15
	DEC	L
	
	endm

	; copy stream data to the next buffer when the 68k bus is available
	macro	preloadBuffer
	
	EXX		; *

	LD	A, (RSC68KLOCKED)
	OR	B
	RLCA
	JR	C, .busy_or_buffer_full

	LDI

.busy_or_buffer_full:

	EXX		; *
		
	endm
	
	; run per sample background tasks
	macro	sampleYield idx

	if	idx == 0
		; nothing (chunk change will take a bit of time already)
	else
	if	idx == 1
		preloadBuffer
	else
	if	idx == 2
		preloadBuffer
	else
	; if	idx == 3
		ymWT
	endif
	endif
	endif

	endm

	; play a chunk sample in 8bit mode
	macro	playHiSample smp, idx
	
	ymWSL1
	ymWSH smp

	sampleYield idx

	endm
	
	; play a chunk sample in 9bit mode
	macro	playLoSample smp, idx

	SRL	smp
	ymWSL
	LD	A, smp
	ADD	H		; H = 64 here
	ymWSH A

	sampleYield idx

	endm

; ###########################	    init       ##############################

	ORG	0x0000

init:
	DI			; disable ints
	JP	start		; jump to start


; ###########################	    main       ##############################

	BLOCK	0x0110-$

start:
	; wait for 68k side init
	LD	A, (RSCFLAGS)
	RRCA
	JP	NC, start

	; set config
	LD	A, (RSCBANK)
	setBankFast

	; Enable DAC
	ymW0	0x2b, 0x80
	
	; DAC Pan = LR
	ymW1	0xb6, 0xc0

	; Timer A enabled @ 26390Hz / 4
	ymW0	0x24, 0xfe
	ymW0	0x25, 0x00
	ymW0	0x27, 0x15

	; DAC init sample
	ymW0	0x2a, 0x80
	ymW0	0x2c, 0x08

	; preload buffers
	
	LD	HL, 0x8000
	
	LD	E, (HL)
	INC	L
	LD	D, (HL)
	INC	L
	LD	(RSCFRAMELEFT), DE

	LD	DE, CHUNKBUFFER0
	LD	BC, CHUNKBUFFER_SZ + INDEXBUFFER_SZ
	LDIR

	; init player

	LD	(RSCTMP16BIT), HL
	EXX
	LD	HL, (RSCTMP16BIT)
	EXX

	LD	IYH, CHUNKBUFFER0 >> 10
	LD	A, high INDEXBUFFER1
	LD	(RSCCURIDXBUF), A
	LD	HL, YMPORT0 + 8		; we need L = 8 for the algo and it points on a mirror

	; Z80 side init done
	LD	A, (RSCFLAGS)
	OR	2
	LD	(RSCFLAGS), A

restart:	
	; double buffer handling / switch

	LD	A, (RSCCURIDXBUF)
	XOR	0x10
	LD	(RSCCURIDXBUF), A

	LD	IXH, A
	LD	IXL, 0
	EXX
	XOR	0x10
	LD	D, A
	LD	E, 0
	LD	BC, INDEXBUFFER_SZ - 1		; buffer preload counter
	EXX

	LD	IYL, 0				; block counter (256 blocks)

	; handle 68k track stop request

	LD	A, (RSCFLAGS)
	AND	8
	JP	Z, main_loop

	LD	A, (RSCFLAGS)
	OR	4
	LD	(RSCFLAGS), A

	ymW0	0x2a, 0x80
	ymW0	0x2c, 0x08

stop_loop:
	JR	stop_loop

chunkIdx_hiSmp:
	POP	DE
	playHiSample E, 0
	playHiSample D, 1
	POP	DE
	playHiSample E, 2
	playHiSample D, 3

	DJNZ	chunkIdx_loop

	; main loop, one 8 chunks block at a time

main_loop:
	
	; check for end of frame

	DEC	IYL
	JP	Z, restart

	; load bit shift for 8 chunk idxs
	LD	C, (IX)
	INC	IX

	LD	B, 8

chunkIdx_loop:

	; load chunk index

	LD	E, (IX)
	INC	IX

	; compute chunk address

	LD	D, IYH
	EX	DE, HL		; *
	ADD	HL, HL
	ADD	HL, HL
	LD	SP, HL
	EX	DE, HL		; *

	; play the chunk samples

	SLA	C
	JR	C, chunkIdx_hiSmp
	
	POP	DE
	playLoSample E, 0
	playLoSample D, 1
	POP	DE
	playLoSample E, 2
	playLoSample D, 3
	
	DJNZ	chunkIdx_loop
	JP	main_loop

	END
