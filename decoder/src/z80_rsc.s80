; Z80 driver for replaying RSE SoundChunks PCM streams
; By GliGli

; ###########################	   define      ##############################

	INCLUDE "z80_def.i80"	; basic definitions

	;define	USE_YM_DEBUG_BIT

; ###########################	    var	       ##############################

RSCPARAMS	EQU	0x110

RSCFLAGS	EQU	RSCPARAMS+0x00	// 0: 68k ready; 1: Z80 ready; 2: track finished; 3: stop requested
RSCBANK		EQU	RSCPARAMS+0x01
RSC68KLOCKED	EQU	RSCPARAMS+0x02  // 7: "68k bus locked" flag, managed by the 68k
RSCCURIDXBUF	EQU	RSCPARAMS+0x03
RSCFRAMELEFT	EQU	RSCPARAMS+0x04
RSCTMP16BIT	EQU	RSCPARAMS+0x06

SAMPLES_PER_CHUNK_SHIFT		EQU	2
SAMPLES_PER_CHUNK		EQU	(1 << SAMPLES_PER_CHUNK_SHIFT)
CHUNKS_PER_FRAME		EQU	256

CHUNKBUFFER0	EQU	0x0400
INDEXBUFFER0	EQU	0x0800
CHUNKBUFFER1	EQU	0x1400
INDEXBUFFER1	EQU	0x1800

CHUNKBUFFER_SZ	EQU	(CHUNKS_PER_FRAME * SAMPLES_PER_CHUNK)
INDEXBUFFER_SZ	EQU	256 * 9

; ###########################	   macro       ##############################

	INCLUDE "z80_mac.i80"  ; basic macros

	; data -> YM2612 low reg address
	macro	ymW0 addr, data
	
	LD	HL, YMPORT0

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; data -> YM2612 high reg address
	macro	ymW1 addr, data
	
	LD	HL, YMPORT2

	LD	(HL), addr
	INC	L
	LD	(HL), data
	DEC	L

.wait:	BIT	7, (HL)
	JP	NZ, .wait

	endm
	
	; 8bit sample in A
	macro	ymWS
	
	LD	(YMPORT1), A

	endm

	; wait YM2612 timer A and reset it
	macro	ymWT

.wait:	
	ifdef USE_YM_DEBUG_BIT
		BIT	6, (IX + 0)
	else
		BIT	0, (IX + 0)
	endif
	JP	Z, .wait
	
	ifndef USE_YM_DEBUG_BIT
		LD	(IX + 0), 0x27
		LD	(IX + 1), 0x15
		LD	(IX + 0), 0x2a
	endif

	endm

	; copy stream data to the next buffer when the 68k bus is available
	macro	preloadBuffer
	
	EXX		; *

	LD	A, (RSC68KLOCKED)
	OR	B
	RLA
	JR	C, .busy_or_buffer_full

	LDI

.busy_or_buffer_full:

	EXX		; *
		
	endm
	
	; run per sample background tasks
	macro	sampleYield idx

	ifdef USE_YM_DEBUG_BIT
		preloadBuffer
		ymWT
	else
		if idx > 0
			preloadBuffer
		endif
		if !(idx & 1)
			ymWT
		endif
	endif

	endm

	; play a chunk sample in 8bit mode
	macro	playHiSample idx
	
	sampleYield idx

	LD	A, (DE)

	INC	D
	
	ymWS

	endm
	
	; play a chunk sample in 9bit mode
	macro	playLoSample idx
	
	if idx > 0
		INC	D
	endif

	sampleYield idx

	LD	A, (DE)

	SRL	A
	ADD	64

	ymWS

	endm

	; play the chunk samples
	macro	playChunkSamples chkIdx

	RL	C
	JR	C, .hiSmp
	
	playLoSample 0
	playLoSample 1
	playLoSample 2
	playLoSample 3

	if chkIdx = 0
		JP chunkIdx_loop
	else
		DJNZ	chunkIdx_start
		JP	main_loop
	endif

.hiSmp:
	playHiSample 0
	playHiSample 1
	playHiSample 2
	playHiSample 3

.end
	endm

; ###########################	    init       ##############################

	ORG	0x0000

init:
	DI			; disable ints
	JP	start		; jump to start


; ###########################	    main       ##############################

	BLOCK	RSCPARAMS + 0x10 - $

start:
	; wait for 68k side init
	LD	A, (RSCFLAGS)
	RRCA
	JP	NC, start

	; set config
	LD	A, (RSCBANK)
	setBankFast

	; Enable DAC
	ymW0	0x2b, 0x80
	
	; DAC Pan = LR
	ymW1	0xb6, 0xc0

	ifdef USE_YM_DEBUG_BIT
		; using SYNC debug bit (set one cycle every 52780Hz)
		ymW0	0x21, 0x41
	else
		; Timer A enabled @ 26390Hz / 4
		ymW0	0x24, 0xff
		ymW0	0x25, 0x00
		ymW0	0x27, 0x15
	endif

	; DAC init sample

	ymW0	0x2c, 0x08
	ymW0	0x2a, 0x80

	; preload buffers
	
	LD	HL, 0x8000
	
	LD	E, (HL)
	INC	L
	LD	D, (HL)
	INC	L
	LD	(RSCFRAMELEFT), DE

	LD	DE, CHUNKBUFFER0
	LD	BC, CHUNKBUFFER_SZ + INDEXBUFFER_SZ
	LDIR

	; init player

	LD	(RSCTMP16BIT), HL
	EXX
	LD	HL, (RSCTMP16BIT)
	EXX

	LD	IX, YMPORT0
	LD	A, high INDEXBUFFER1
	LD	(RSCCURIDXBUF), A

	; Z80 side init done
	LD	A, (RSCFLAGS)
	OR	2
	LD	(RSCFLAGS), A

restart:	
	; double buffer handling / switch

	LD	A, (RSCCURIDXBUF)
	XOR	0x10
	LD	(RSCCURIDXBUF), A

	LD	H, A
	LD	L, 0
	LD	SP, HL
	EXX
	XOR	0x10
	LD	D, A
	LD	E, 0
	LD	BC, INDEXBUFFER_SZ - 1		; buffer preload counter
	EXX

	LD	IYL, 0				; block counter (256 blocks)
	LD	H, high CHUNKBUFFER0

	; handle 68k track stop request

	LD	A, (RSCFLAGS)
	AND	8
	JP	Z, main_loop

	LD	A, (RSCFLAGS)
	OR	4
	LD	(RSCFLAGS), A

	ymW0	0x2a, 0x80
	ymW0	0x2c, 0x08

	HALT

main_loop:
	
	; check for end of frame

	DEC	IYL
	JR	Z, restart

	; load bit shift for 8 chunk idxs
	POP	BC
	DEC	SP

	LD	B, 4
	JP	chunkIdx_start

chunkIdx_loop:

	; compute chunk address

	LD	D, H
	LD	E, L

	playChunkSamples 1

	DEC	B
	JP	Z, main_loop

chunkIdx_start:

	; load chunk index

	POP	DE
	LD	L, D

	; compute chunk address

	LD	D, H

	playChunkSamples 0

	JP	chunkIdx_loop

	END
